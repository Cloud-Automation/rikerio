#ifndef __RIKERIO_LIB_H__
#define __RIKERIO_LIB_H__

#include "stdint.h"
#include "sys/types.h"

#include "filesystem"
#include "string"
#include "vector"

#define RIO_VERSION_MAJOR @VERSION_MAJOR@
#define RIO_VERSION_MINOR @VERSION_MINOR@

#define PACKED __attribute__((__packed__))

namespace RikerIO {

static const int result_ok = 0;
static const int result_error = -1;

static const std::string root_path = "/var/run/rikerio";
static const std::string persistent_path = "/var/lib/rikerio";
static const std::string allocation_filename = "alloc";
static const std::string shared_memory_filename = "shm";
static const std::string last_changed_filename = "last";

enum class Type {
    UNDEF  = 0,
    BIT    = 1,
    BOOL   = 2,
    UINT8  = 3,
    INT8   = 4,
    UINT16 = 5,
    INT16  = 6,
    UINT32 = 7,
    INT32  = 8,
    UINT64 = 9,
    INT64  = 10,
    FLOAT  = 11,
    DOUBLE = 12,
    STRING = 13
};

typedef char ID[64];
typedef uint32_t ByteOffset;
typedef uint8_t BitIndex;
typedef uint32_t ByteSize;
typedef uint32_t BitSize;

BitSize get_bitsizeof(Type type);
ByteSize calc_bytesize(BitSize);

struct PACKED Profile {
    ID id;
    size_t byte_size;
    int sem_key;
    int sem_id;
    uint32_t base_cycle;
    uint8_t* ptr;
};

struct PACKED Allocation {
    uint32_t offset;
    uint32_t byte_size;
    ID id; // optional
    uint8_t* ptr;
    uint32_t local_byte_offset;
    Allocation() : offset(0), byte_size(0), id(""), ptr(NULL), local_byte_offset(0) { }
};

struct PACKED DataPoint {
    RikerIO::ID id;
    Type type;
    BitSize bit_size;
    ByteOffset byte_offset;
    BitIndex bit_index;
    uint8_t* ptr;
    DataPoint() :
        id(""),
        type(Type::UNDEF),
        bit_size(0),
        byte_offset(0),
        bit_index(0),
        ptr(NULL) { }
    DataPoint(Type type, ByteSize bs = 0) :
        id(""),
        type(type),
        bit_size(RikerIO::get_bitsizeof(type)),
        byte_offset(0),
        bit_index(0),
        ptr(NULL) {

        if (type == Type::UNDEF || type == Type::STRING) {
            bit_size = bs * 8;
        }

    }
};

std::string type_to_string(Type);


int init(const std::string&, Profile&);

/**
 * @brief allocate new memory of the shared memory from a specific profile
 * @param char* profileId
 * @param uint32_t requested memory size
 * @param char[32] optional id
 * @param void** pointer
 * @param uint32_t* offset
 * @returns 0 on success, -1 on error
 */
int alloc(const Profile&, uint32_t, const std::string&, Allocation&);

/**
 * @brief allocate new memory of the shared memory from a specific profile
 * @param char* profileId
 * @param uint32_t requested memory size
 * @param void** pointer
 * @param uint32_t* offset
 * @returns 0 on success, -1 on error
 */
int realloc(const Profile&, uint32_t, const std::string&, Allocation&);

/**
 * @brief free allocation on a profile with a offset
 * @param char* profileId
 * @param uint32_t offset
 * @returns 0 on success, -1 on error
 */
int dealloc(const Profile&, const std::string&);

/**
 * @brief List all allocations
 * @param rio_profile_t profile
 * @param Allocation[] List of allocations
 * @param unsigned int count of preallocated list items
 * @param unsigned int* number of items copied to the list
 * @returns 0 on success, -1 on error
 */
int list(const Profile&, std::vector<Allocation>&);

/**
 * @brief lock semaphore
 * @param int semaphore id
 */
int lock(const Profile&);

/**
 * @brief unlock semaphore
 * @param int semaphore id
 */
int unlock(const Profile&);

/**
 * @brief get last time something happend in this profile
 */
std::filesystem::file_time_type last_write(const Profile&);

namespace Data {

/**
 * @brief Add new link address
 * @param rio_profile_t profileId
 * @param rio_link_t link key
 * @param rio_adr_t adr, NULL removed data
 * @returns 0 on success, -1 on failure
 */
int set(const Profile&, Allocation&, const std::string&, DataPoint&);
int set(const Profile&, const Allocation&, const std::string&, ByteOffset, BitIndex, DataPoint&);
int set(const Profile&, const std::string&, ByteOffset, BitIndex, DataPoint&);

int remove(const Profile&, const std::string&);

/**
 * @brief Get all adr from a link.
 * @param rio_profile_t profile
 * @param rio_link_t link
 * @param rio_adr_t[] address list
 * @param unsigned int number of list items in the preallocated list
 * @param unsigned int* number of items copied to the list
 * @returns 0 on success or -1 on error
 */
int get(const RikerIO::Profile&, const std::string&, RikerIO::DataPoint&);

/**
 * @brief get list of links
 * @param char* profileId
 * @param rio_link_t[] return list of links
 * @param unsigned int number of preallocated items in the list
 * @param unsigned int* number of items copied to the list
 * @return 0 on success, -1 on error
 */
int list(const RikerIO::Profile&, std::vector<std::string>&);

}

namespace Link {
/**
 * @brief create alias.
 * @param rio_profile_t profile
 * @param rio_alias_t alias
 * @param rio_link_t link
 * @returns 0 on success, -1 on failure
 */
int set(const RikerIO::Profile&, const std::string&, const std::string&);

/**
 * @brief remove alias.
 * @param rio_profile_t profile
 * @param rio_link_t*
 * @param rio_data_t* specific to remove or null for all
 * @returns 0 on success, -1 on failure
 */
int remove(const Profile&, const std::string&, const std::string&);

int remove(const Profile&, const std::string&);

/**
 * @brief get linkcount from alias
 * @param rio_profile_t profileId
 * @param rio_alias_t alias
 * @params unsigned int* pointer to count value
 * @returns number of links, -1 on error
 */
int get(const Profile&, const std::string&, std::vector<std::string>&);


int list(const Profile&, std::vector<std::string>&);

}

}
#endif
